<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.Lifetimes</name>
    </assembly>
    <members>
        <member name="T:JetBrains.Annotations.CanBeNullAttribute">
            <summary>
            Indicates that the value of the marked element could be <c>null</c> sometimes,
            so the check for <c>null</c> is necessary before its usage.
            </summary>
            <example><code>
            [CanBeNull] object Test() => null;
            
            void UseTest() {
              var p = Test();
              var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.NotNullAttribute">
            <summary>
            Indicates that the value of the marked element could never be <c>null</c>.
            </summary>
            <example><code>
            [NotNull] object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.ItemNotNullAttribute">
            <summary>
            Can be applied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can never be null.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.ItemCanBeNullAttribute">
            <summary>
            Can be applied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can be null.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.ImplicitNotNullAttribute">
            <summary>
            Implicitly apply [NotNull]/[ItemNotNull] annotation to all the of type members and parameters
            in particular scope where this annotation is used (type declaration or whole assembly).
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that the marked method builds string by format pattern and (optional) arguments.
            Parameter, which contains format string, should be given in constructor. The format string
            should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>-like form.
            </summary>
            <example><code>
            [StringFormatMethod("message")]
            void ShowError(string message, params object[] args) { /* do something */ }
            
            void Foo() {
              ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
            }
            </code></example>
        </member>
        <member name="M:JetBrains.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as format-string
            </param>
        </member>
        <member name="T:JetBrains.Annotations.ValueProviderAttribute">
            <summary>
            For a parameter that is expected to be one of the limited set of values.
            Specify fields of which type should be used as values for this parameter.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one
            of the parameters of the caller function. For example, ReSharper annotates
            the parameter of <see cref="T:System.ArgumentNullException"/>.
            </summary>
            <example><code>
            void Foo(string param) {
              if (param == null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.NotifyPropertyChangedInvocatorAttribute">
             <summary>
             Indicates that the method is contained in a type that implements
             <c>System.ComponentModel.INotifyPropertyChanged</c> interface and this method
             is used to notify that some property value changed.
             </summary>
             <remarks>
             The method should be non-static and conform to one of the supported signatures:
             <list>
             <item><c>NotifyChanged(string)</c></item>
             <item><c>NotifyChanged(params string[])</c></item>
             <item><c>NotifyChanged{T}(Expression{Func{T}})</c></item>
             <item><c>NotifyChanged{T,U}(Expression{Func{T,U}})</c></item>
             <item><c>SetProperty{T}(ref T, T, string)</c></item>
             </list>
             </remarks>
             <example><code>
             public class Foo : INotifyPropertyChanged {
               public event PropertyChangedEventHandler PropertyChanged;
             
               [NotifyPropertyChangedInvocator]
               protected virtual void NotifyChanged(string propertyName) { ... }
            
               string _name;
             
               public string Name {
                 get { return _name; }
                 set { _name = value; NotifyChanged("LastName"); /* Warning */ }
               }
             }
             </code>
             Examples of generated notifications:
             <list>
             <item><c>NotifyChanged("Property")</c></item>
             <item><c>NotifyChanged(() =&gt; Property)</c></item>
             <item><c>NotifyChanged((VM x) =&gt; x.Property)</c></item>
             <item><c>SetProperty(ref myField, value, "Property")</c></item>
             </list>
             </example>
        </member>
        <member name="T:JetBrains.Annotations.ContractAnnotationAttribute">
            <summary>
            Describes dependency between method input and output.
            </summary>
            <syntax>
            <p>Function Definition Table syntax:</p>
            <list>
            <item>FDT      ::= FDTRow [;FDTRow]*</item>
            <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
            <item>Input    ::= ParameterName: Value [, Input]*</item>
            <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
            <item>Value    ::= true | false | null | notnull | canbenull</item>
            </list>
            If method has single input parameter, it's name could be omitted.<br/>
            Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same)
            for method output means that the methods doesn't return normally.<br/>
            <c>canbenull</c> annotation is only applicable for output parameters.<br/>
            You can use multiple <c>[ContractAnnotation]</c> for each FDT row,
            or use single attribute with rows separated by semicolon.<br/>
            </syntax>
            <examples><list>
            <item><code>
            [ContractAnnotation("=> halt")]
            public void TerminationMethod()
            </code></item>
            <item><code>
            [ContractAnnotation("halt &lt;= condition: false")]
            public void Assert(bool condition, string text) // regular assertion method
            </code></item>
            <item><code>
            [ContractAnnotation("s:null => true")]
            public bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code></item>
            <item><code>
            // A method that returns null if the parameter is null,
            // and not null if the parameter is not null
            [ContractAnnotation("null => null; notnull => notnull")]
            public object Transform(object data) 
            </code></item>
            <item><code>
            [ContractAnnotation("s:null=>false; =>true,result:notnull; =>false, result:null")]
            public bool TryParse(string s, out Person result)
            </code></item>
            </list></examples>
        </member>
        <member name="T:JetBrains.Annotations.LocalizationRequiredAttribute">
            <summary>
            Indicates that marked element should be localized or not.
            </summary>
            <example><code>
            [LocalizationRequiredAttribute(true)]
            class Foo {
              string str = "my string"; // Warning: Localizable string
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.CannotApplyEqualityOperatorAttribute">
            <summary>
            Indicates that the value of the marked type (or its derivatives)
            cannot be compared using '==' or '!=' operators and <c>Equals()</c>
            should be used instead. However, using '==' or '!=' for comparison
            with <c>null</c> is always permitted.
            </summary>
            <example><code>
            [CannotApplyEqualityOperator]
            class NoEquality { }
            
            class UsesNoEquality {
              void Test() {
                var ca1 = new NoEquality();
                var ca2 = new NoEquality();
                if (ca1 != null) { // OK
                  bool condition = ca1 == ca2; // Warning
                }
              }
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.BaseTypeRequiredAttribute">
            <summary>
            When applied to a target attribute, specifies a requirement for any type marked
            with the target attribute to implement or inherit specific type or types.
            </summary>
            <example><code>
            [BaseTypeRequired(typeof(IComponent)] // Specify requirement
            class ComponentAttribute : Attribute { }
            
            [Component] // ComponentAttribute requires implementing IComponent interface
            class MyComponent : IComponent { }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.UsedImplicitlyAttribute">
            <summary>
            Indicates that the marked symbol is used implicitly (e.g. via reflection, in external library),
            so this symbol will not be marked as unused (as well as by other usage inspections).
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.MeansImplicitUseAttribute">
            <summary>
            Should be used on attributes and causes ReSharper to not mark symbols marked with such attributes
            as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.Access">
            <summary>Only entity marked with attribute considered used.</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.Assign">
            <summary>Indicates implicit assignment to a member.</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
            <summary>
            Indicates implicit instantiation of a type with fixed constructor signature.
            That means any unused constructor parameters won't be reported as such.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
            <summary>Indicates implicit instantiation of a type.</summary>
        </member>
        <member name="T:JetBrains.Annotations.ImplicitUseTargetFlags">
            <summary>
            Specify what is considered used implicitly when marked
            with <see cref="T:JetBrains.Annotations.MeansImplicitUseAttribute"/> or <see cref="T:JetBrains.Annotations.UsedImplicitlyAttribute"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseTargetFlags.Members">
            <summary>Members of entity marked with attribute are considered used.</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseTargetFlags.WithMembers">
            <summary>Entity marked with attribute and all its members considered used.</summary>
        </member>
        <member name="T:JetBrains.Annotations.PublicAPIAttribute">
            <summary>
            This attribute is intended to mark publicly available API
            which should not be removed and so is treated as used.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.InstantHandleAttribute">
            <summary>
            Tells code analysis engine if the parameter is completely handled when the invoked method is on stack.
            If the parameter is a delegate, indicates that delegate is executed while the method is executed.
            If the parameter is an enumerable, indicates that it is enumerated while the method is executed.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.PureAttribute">
            <summary>
            Indicates that a method does not make any observable state changes.
            The same as <c>System.Diagnostics.Contracts.PureAttribute</c>.
            </summary>
            <example><code>
            [Pure] int Multiply(int x, int y) => x * y;
            
            void M() {
              Multiply(123, 42); // Waring: Return value of pure method is not used
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.MustUseReturnValueAttribute">
            <summary>
            Indicates that the return value of method invocation must be used.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.ProvidesContextAttribute">
            <summary>
            Indicates the type member or parameter of some type, that should be used instead of all other ways
            to get the value that type. This annotation is useful when you have some "context" value evaluated
            and stored somewhere, meaning that all other ways to get this value must be consolidated with existing one.
            </summary>
            <example><code>
            class Foo {
              [ProvidesContext] IBarService _barService = ...;
            
              void ProcessNode(INode node) {
                DoSomething(node, node.GetGlobalServices().Bar);
                //              ^ Warning: use value of '_barService' field
              }
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.PathReferenceAttribute">
            <summary>
            Indicates that a parameter is a path to a file or a folder within a web project.
            Path can be relative or absolute, starting from web root (~).
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.CollectionAccessAttribute">
            <summary>
            Indicates how method, constructor invocation or property access
            over collection type affects content of the collection.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.CollectionAccessType.None">
            <summary>Method does not use or modify content of the collection.</summary>
        </member>
        <member name="F:JetBrains.Annotations.CollectionAccessType.Read">
            <summary>Method only reads content of the collection but does not modify it.</summary>
        </member>
        <member name="F:JetBrains.Annotations.CollectionAccessType.ModifyExistingContent">
            <summary>Method can change content of the collection but does not add new elements.</summary>
        </member>
        <member name="F:JetBrains.Annotations.CollectionAccessType.UpdatedContent">
            <summary>Method can add new elements to the collection.</summary>
        </member>
        <member name="T:JetBrains.Annotations.AssertionMethodAttribute">
            <summary>
            Indicates that the marked method is assertion method, i.e. it halts control flow if
            one of the conditions is satisfied. To set the condition, mark one of the parameters with 
            <see cref="!:AssertionConditionAttribute"/> attribute.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.LinqTunnelAttribute">
            <summary>
            Indicates that method is pure LINQ method, with postponed enumeration (like Enumerable.Select,
            .Where). This annotation allows inference of [InstantHandle] annotation for parameters
            of delegate type by analyzing LINQ method chains.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.NoEnumerationAttribute">
            <summary>
            Indicates that IEnumerable, passed as parameter, is not enumerated.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.RegexPatternAttribute">
            <summary>
            Indicates that parameter is regular expression pattern.
            </summary>
        </member>
        <member name="T:JetBrains.Collections.CollectionEx">
            <summary>
            Extension methods for collections
            </summary>
        </member>
        <member name="M:JetBrains.Collections.CollectionEx.ContentHashCode``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Calculates polynomial hash code for collection.
            Return 0 if collection == null.
            Return `seed` (in current implementation 0x2D2816FE) if collection is empty.
            In current implementation polynomial factor is 31.
            </summary>
            <param name="collection"></param>
            <typeparam name="T"></typeparam>
            <returns>((seed * factor + collection[0]?.GetHashCode() ?? 0) * factor + collection[1]?.GetHashCode() ?? 0) * factor + ... </returns>
        </member>
        <member name="M:JetBrains.Collections.CollectionEx.TryDequeue``1(System.Collections.Generic.Queue{``0},``0@)">
            <summary>
            Dequeue <paramref name="queue"/> if it's not empty (or do nothing).
            </summary>
            <param name="queue"></param>
            <param name="res"><see cref="M:System.Collections.Generic.Queue`1.Dequeue"/> if <paramref name="queue"/>.Count > 0 at method start, `default{T}` otherwise</param>
            <typeparam name="T"></typeparam>
            <returns>`true` if <paramref name="queue"/>.Count > 0 at method start, `false` otherwise</returns>
        </member>
        <member name="M:JetBrains.Collections.CollectionEx.Enqueued``1(System.Collections.Generic.Queue{``0},``0)">
            <summary>
            Same as <see cref="M:System.Collections.Generic.Queue`1.Enqueue(`0)"/> but returns added element
            </summary>
            <param name="queue"></param>
            <param name="toEnqueue">Element to enqueue into <paramref name="queue"/></param>
            <typeparam name="T"></typeparam>
            <returns>Added element <paramref name="toEnqueue"/></returns>
        </member>
        <member name="T:JetBrains.Collections.CompactList`1">
            <summary>
            Saves memory footprint and traffic for lists with single element: doesn't allocate real list
            until number of elements is more then 1.
            <see cref="M:JetBrains.Collections.CompactList`1.GetEnumerator"/> return struct that should save memory traffic during enumeration.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.EmptyEnumerator`1">
            <summary>
            Enumerator for empty collection.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.JetKeyValuePair">
            <summary>
            Facilitates <see cref="T:System.Collections.Generic.KeyValuePair`2"/>
            </summary>
        </member>
        <member name="T:JetBrains.Collections.IPriorityQueue`1">
            <summary>
            JetBrains interface of priority queue data structure.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.JetPriorityQueue`1">
            <summary>
            JetBrains implementation of priority queue data structure.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.BlockingPriorityQueue`1">
            <summary>
            Thread-safe implementation of priority queue data structure.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:JetBrains.Collections.BlockingPriorityQueue`1.ExtractOrBlock">
            <summary>
            Returns first element from queue or waits until it appears. In case of lifetime termination throws PCE.
            </summary>
            <returns>First element in queue</returns>
        </member>
        <member name="M:JetBrains.Collections.BlockingPriorityQueue`1.Enqueue(`0)">
            <summary>
            Enqueues an item and returns the total number of items in the queue right after enqueueing, in a thread-safe-consistent manner.
            </summary>
        </member>
        <member name="M:JetBrains.Collections.BlockingPriorityQueue`1.ToArray">
            <summary>
            Copies data to an array, thread-safely.
            </summary>
        </member>
        <member name="M:JetBrains.Collections.PriorityQueueEx.Enqueue``1(JetBrains.Collections.IPriorityQueue{``0},``0)">
            <summary>
            Same as <see cref="!:IPriorityQueue&lt;T&gt;.Add"/>
            </summary>
            <param name="queue"></param>
            <param name="val"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.ReferenceEqualityComparer`1">
            <summary>
            Comparer that uses reference equality.
            Usage: `ReferenceEqualityComparer{T}.Default`
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.SingletonEnumerator`1">
            <summary>
            Enumerator for imaginary collection from single value
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.Synchronized.SynchronizedDictionary`2">
            <summary>
            This dictionary is used for Net3.5 as a poor replacement of ConcurrentDictionary.
            All methods are synchronized. <see cref="M:JetBrains.Collections.Synchronized.SynchronizedDictionary`2.GetEnumerator"/> copies whole content so
            you can change collection as you want during enumeration. 
            </summary>
            <typeparam name="TK"></typeparam>
            <typeparam name="TV"></typeparam>
        </member>
        <member name="M:JetBrains.Collections.Synchronized.SynchronizedDictionary`2.GetEnumerator">
            <summary>
            Copies content of collection: O(n) CPU and memory complexity.
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Collections.Synchronized.SynchronizedList`1">
            <summary>
            This is a thread-safe list with all methods synchronized.
            <see cref="M:JetBrains.Collections.Synchronized.SynchronizedList`1.GetEnumerator"/> copies whole content so
            you can change collection as you want during enumeration. 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:JetBrains.Collections.Synchronized.SynchronizedList`1.GetEnumerator">
            <summary>
            Copies content of collection: O(n) CPU and memory complexity.
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Collections.Synchronized.SynchronizedSet`1">
             <summary>
             This is a thread-safe set with all methods synchronized.
             <see cref="M:JetBrains.Collections.Synchronized.SynchronizedSet`1.GetEnumerator"/> copies whole content so
             you can change collection as you want during enumeration.
            
             Useful pattern for filtering):
             <code>
               using (en = syncSet.GetEnumerator()) {
                 while (en.MoveNext()) {
                   if (some_condition(en.Current))
                     syncSet.Remove(en.Current);
                 }
               }
             </code>
             </summary>
             <typeparam name="T"></typeparam>
        </member>
        <member name="M:JetBrains.Collections.Synchronized.SynchronizedSet`1.GetEnumerator">
            <summary>
            Copies content of collection: O(n) CPU and memory complexity.
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Collections.Viewable.AddRemove">
            <summary>
            Defines whether the event kind is <see cref="F:JetBrains.Collections.Viewable.AddRemove.Add"/> or <see cref="F:JetBrains.Collections.Viewable.AddRemove.Remove"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Collections.Viewable.AddUpdateRemove">
            <summary>
            Defines whether the event kind is <see cref="F:JetBrains.Collections.Viewable.AddUpdateRemove.Add"/>, <see cref="F:JetBrains.Collections.Viewable.AddUpdateRemove.Update"/> or <see cref="F:JetBrains.Collections.Viewable.AddUpdateRemove.Remove"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Util.EmptyArray`1">
            <summary>
            Reuses the single instance of an empty array (one per type). If possible, prefer <code>EmptyList{T}.InstanceList</code>
            because each time you enumerate empty array, new <code>Array.SZArrayEnumerator</code> class instance is being created.
            </summary>
        </member>
        <member name="T:JetBrains.Util.EmptyArray">
            <summary>
            Reuses the single instance of an empty array (one per type).
            </summary>
        </member>
        <member name="M:JetBrains.Util.EmptyArray.GetInstance``1">
            <summary>Synonym for <see cref="F:JetBrains.Util.EmptyArray`1.Instance"/></summary>
        </member>
        <member name="F:JetBrains.Util.MethodImplAdvancedOptions.AggressiveInlining">
            <summary>
            Corresponds to <code>MethodImplOptions.AggressiveInlining</code> value in 4.5 framework. This value is just swallowed in lower frameworks
            </summary>
        </member>
        <member name="T:JetBrains.Util.BitHacks">
            <summary>
            Inspired by http://graphics.stanford.edu/~seander/bithacks.html
            </summary>
        </member>
        <member name="M:JetBrains.Util.BitHacks.Log2Floor(System.Int32)">
            <summary>
            Returns largest non-negative integer <c>y</c> such that <c>2^y&lt;=x</c> if <c>x&gt;0</c>, <c>0</c> if <c>x=0</c>, or throw ArgumentException if <c>x&lt;0</c> 
            </summary>
            <param name="x">Must be greater than or equal to zero.</param>
            <returns><c>y : 2^y&lt;=x</c></returns>
        </member>
        <member name="M:JetBrains.Util.BitHacks.Log2Ceil(System.Int64)">
            <summary>
            Returns lowest non-negative integer <c>y</c> such that <c>2^y&gt;=x</c> if <c>x&gt;=0</c> or throw ArgumentException if <c>x&lt;0</c> 
            </summary>
            <param name="x">Must be greater than or equal to zero.</param>    
            <returns><c>y : 2^y&gt;=x</c></returns>    
        </member>
        <member name="M:JetBrains.Util.BitHacks.NumberOfBitSet(System.Int32)">
            <summary>
            Return number of <c>1</c>-s in binary representation of <c>x</c>
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Util.Util.Cast32BitEnum`1">
            <summary>
            For converting generic enum based on 32bit integer into in or uint.
            Will throw <see cref="T:System.InvalidOperationException"/> in static ctor if <c>Enum.GetUnderlyingType(typeof(T)) </c> is not int or uint.
            </summary>
            <typeparam name="T">Enum that is based on int or uint</typeparam>
        </member>
        <member name="T:JetBrains.Util.Util.Cast64BitEnum`1">
            <summary>
            For converting generic enum based on 64bit integer into in or ulong.
            Will throw <see cref="T:System.InvalidOperationException"/> in static ctor if <c>Enum.GetUnderlyingType(typeof(T)) </c> is not long or ulong.
            </summary>
            <typeparam name="T">Enum that is based on long or ulong</typeparam>
        </member>
        <member name="T:JetBrains.Util.Util.CastTo`1">
            <summary>
            !!! Use it with caution. Main purpose is enum to/from int casting without boxing !!!
            </summary>
        </member>
        <member name="M:JetBrains.Util.Util.CastTo`1.From``1(``0)">
            <summary>
            /// https://stackoverflow.com/questions/1189144/c-sharp-non-boxing-conversion-of-generic-enum-to-int/23391746#23391746
            Casts <see cref="!:TFrom"/> to TTo  without boxing for value types. Useful in generic methods.
            The only problem is that this method requires around 50ms on startup to warm up.
            So for real hardcore see <see cref="!:ReinterpretFrom&lt;TFrom&gt;"/>  
            </summary>
            <typeparam name="TFrom">Source type to cast from. Usually a generic type.</typeparam>
        </member>
        <member name="T:JetBrains.Util.Util.Statics">
            <summary>
            Represents global statics in a stack-like way 
            </summary>
        </member>
        <member name="M:JetBrains.Util.Util.Statics.For``1">
            <summary>
            Gets statics holder for type <see cref="!:T"/>
            </summary>
            <typeparam name="T"></typeparam>
            <returns>Stack-like holder</returns>
        </member>
        <member name="T:JetBrains.Util.Util.Types">
            <summary>
            Extensions to <see cref="T:System.Type"/>
            </summary>
        </member>
        <member name="F:JetBrains.Util.Util.Types.ourPrimitives">
            <summary>
            To prettify Int32, Int64 and so on.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Util.Types.ToString(System.Type,System.Boolean,System.Boolean)">
            <summary>
            Different <c>ToString()</c> of <see cref="T:System.Type"/>.
            
            Samples are provide for:  
            <code>
            namespace Foo { 
              class Outer&lt;T1&gt;
              {
                 internal class Inner&lt;T2&gt; {}
              }    
            }
            
            </code>     
            </summary>
            <param name="thisType"><c>typeof(Outer&lt;string&gt;.Inner&lt;int&gt;)</c></param>
            <param name="withNamespaces">if `true` (and <see cref="!:withGenericArguments"/> == `false`) then <c>Foo.Outer+Inner</c> else <c>Outer+Inner</c> </param>
            <param name="withGenericArguments">if `true` (and <see cref="!:withNamespaces"/> == `false`) then <c>Outer&lt;string&gt;+Inner&lt;int&gt;</c> else <c>Outer+Inner</c> </param>
            <returns>More natural than <see cref="M:System.Type.ToString"/> string representation of type</returns>
        </member>
        <member name="M:JetBrains.Util.ReflectionUtil.GetSetter(System.Reflection.MemberInfo)">
            <summary>
            Return setter for either field or property info
            </summary>
        </member>
        <member name="M:JetBrains.Util.ReflectionUtil.TryGetSetter(System.Reflection.MemberInfo)">
            <summary>
            Return setter for either field or property info, or null if can't be set.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ReflectionUtil.GetGetter(System.Reflection.MemberInfo)">
            <summary>
            Return getter for either field or property
            </summary>
        </member>
        <member name="M:JetBrains.Util.ReflectionUtil.GetReturnType(System.Reflection.MemberInfo)">
            <summary>
            Get field or property type.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ReflectionUtil.GetPropertyValueSafe``1(System.Object,System.String,``0)">
            <summary>
            Evaluates property value available on object or any of the interfaces it implements
            </summary>
            <param name="o">Object to invoke property of</param>
            <param name="propertyName">Name of the property</param>
            <param name="defaultValue">Default value to return if failed</param>
            <typeparam name="T">Expected return type</typeparam>
            <returns>Evaluated property value or default value</returns>
        </member>
        <member name="T:JetBrains.Core.Maybe`1">
            <summary>
            Implementation of 'maybe' monad. Either <seealso cref="P:JetBrains.Core.Maybe`1.HasValue"/> is `true` and <seealso cref="P:JetBrains.Core.Maybe`1.Value"/> doesn't throw exception or `false`. 
            
            default(Maybe) == Maybe.None
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:JetBrains.Core.Maybe`1.Value">
            <summary>
            
            </summary>
            <exception cref="T:System.InvalidOperationException">if <seealso cref="P:JetBrains.Core.Maybe`1.HasValue"/> == `false`</exception>
        </member>
        <member name="T:JetBrains.Core.Nothing">
            <summary>
            Type that has no instances. Subclass of all classes, so can be casted to any class.
            </summary>
        </member>
        <member name="M:JetBrains.Core.Nothing.As``1">
            <summary>
            Always throws <see cref="T:System.InvalidOperationException"/>. Could be used as a return value for unreachable code.
            </summary>
            <typeparam name="T"></typeparam>
            <returns>always fail</returns>
        </member>
        <member name="M:JetBrains.Core.Nothing.Unreachable``1">
            <summary>
            Always throws <see cref="T:System.InvalidOperationException"/>. Could be used as a return value for unreachable code.
            </summary>
            <typeparam name="T"></typeparam>
            <returns>always fail</returns>
        </member>
        <member name="M:JetBrains.Core.Nothing.Unreachable">
            <summary>
            Always throws <see cref="T:System.InvalidOperationException"/>. Could be used as an assertion in unreachable code.
            </summary>
            <returns>always fail</returns>
        </member>
        <member name="T:JetBrains.Core.Result">
            <summary>
            Helper methods for <see cref="T:JetBrains.Core.Result`1" /> and <see cref="T:JetBrains.Core.Result`2"/> building
            </summary>
        </member>
        <member name="F:JetBrains.Core.Result.EmptyFailMessage">
            <summary>
            Message that is being applied to Result.Fail when no message provided 
            </summary>
        </member>
        <member name="M:JetBrains.Core.Result.Success``1(``0)">
            <summary>
            Creates successful <see cref="T:JetBrains.Core.Result`1"/> with value <see cref="!:value"/>
            </summary>
            <param name="value"></param>
            <typeparam name="T"></typeparam>
            <returns>Result with <see cref="P:JetBrains.Core.Result`1.Succeed"/> == true</returns>
        </member>
        <member name="M:JetBrains.Core.Result.Fail(System.Exception,System.Boolean)">
            <summary>
            Creates failed <see cref="T:JetBrains.Core.Result`1"/>
            </summary>
            <param name="exception"></param>
            <param name="captureStackTrace">Try to capture exception stack (if any), could be unwind by <see cref="M:JetBrains.Core.Result`1.Unwrap"/> </param>
            <returns>Result with <see cref="P:JetBrains.Core.Result`1.Succeed"/> == false. Returned type could be implicitly casted to any <see cref="T:JetBrains.Core.Result`1"/></returns>
            <exception cref="T:System.ArgumentNullException">if <see cref="!:exception"/> is null</exception>
        </member>
        <member name="M:JetBrains.Core.Result.Fail``1(System.Exception,``0,System.Boolean)">
            <summary>
            Creates failed <see cref="T:JetBrains.Core.Result`2"/> with corresponding <see cref="!:failValue"/>
            </summary>
            <param name="exception"></param>
            <param name="failValue">Special user-defined value provided for failed Result</param>
            <param name="captureStackTrace">Try to capture exception stack (if any), could be unwind by <see cref="M:JetBrains.Core.Result`1.Unwrap"/> </param>
            <returns>Result with <see cref="P:JetBrains.Core.Result`2.Succeed"/> == false. Returned type could be implicitly casted to any <see cref="T:JetBrains.Core.Result`2"/></returns>
            <exception cref="T:System.ArgumentNullException">if <see cref="!:exception"/> is null</exception>
        </member>
        <member name="M:JetBrains.Core.Result.Fail(System.String)">
            <summary>
            Creates failed <see cref="T:JetBrains.Core.Result`1"/> with <see cref="T:JetBrains.Core.ResultException"/> that wraps provided <see cref="!:message"/>
            </summary>
            <param name="message">Reason of failure. If not defined, <see cref="F:JetBrains.Core.Result.EmptyFailMessage"/> is used.</param>
            <returns>Result with <see cref="P:JetBrains.Core.Result`1.Succeed"/> == false. Returned type could be implicitly casted to any <see cref="T:JetBrains.Core.Result`1"/></returns>
        </member>
        <member name="M:JetBrains.Core.Result.Fail``1(System.String,``0)">
            <summary>
            Creates failed <see cref="T:JetBrains.Core.Result`2"/> with <see cref="T:JetBrains.Core.ResultException"/> that wraps provided <see cref="!:message"/>
            </summary>
            <param name="message">Reason of failure. If not defined, <see cref="F:JetBrains.Core.Result.EmptyFailMessage"/> is used.</param>
            <param name="failValue">Special user-defined value provided for failed Result</param>
            <returns>Result with <see cref="P:JetBrains.Core.Result`2.Succeed"/> == false. Returned type could be implicitly casted to any <see cref="T:JetBrains.Core.Result`1"/></returns>
        </member>
        <member name="M:JetBrains.Core.Result.FailWithValue``1(``0)">
            <summary>
            Creates failed <see cref="T:JetBrains.Core.Result`1"/> with message= <see cref="F:JetBrains.Core.Result.EmptyFailMessage"/> and user-defined failure parameter 
            </summary>
            <param name="failValue">Special user-defined value provided for failed Result</param>
            <returns>Result with <see cref="P:JetBrains.Core.Result`2.Succeed"/> == false. Returned type could be implicitly casted to any <see cref="T:JetBrains.Core.Result`1"/></returns>
        </member>
        <member name="M:JetBrains.Core.Result.Canceled">
            <summary>
            Creates special failed <see cref="T:JetBrains.Core.Result`1"/> that wraps <see cref="T:System.OperationCanceledException"/>
            </summary>
            <returns>Result with <see cref="P:JetBrains.Core.Result`1.Succeed"/> == false and <see cref="P:JetBrains.Core.Result`1.Canceled"/> == true. Returned type could be implicitly casted to any <see cref="T:JetBrains.Core.Result`1"/></returns>
        </member>
        <member name="M:JetBrains.Core.Result.Canceled(System.OperationCanceledException,System.Boolean)">
            <summary>
            Creates special failed <see cref="T:JetBrains.Core.Result`1"/> that wraps <see cref="T:System.OperationCanceledException"/>
            </summary>
            <param name="exception">Captured OCE that lead to this cancellation</param>
            <param name="captureStackTrace">Try to capture exception stack (if any), could be unwind by <see cref="M:JetBrains.Core.Result`1.Unwrap"/>. </param>
            <returns>Result with <see cref="P:JetBrains.Core.Result`1.Succeed"/> == false and <see cref="P:JetBrains.Core.Result`1.Canceled"/> == true. Returned type could be implicitly casted to any <see cref="T:JetBrains.Core.Result`1"/></returns>
            <exception cref="T:System.ArgumentNullException">if <see cref="!:exception"/> is null</exception>
        </member>
        <member name="F:JetBrains.Core.Result.Unit">
            <summary>
            Void succeed result for <see cref="F:JetBrains.Core.Result.Unit"/> type
            </summary>
        </member>
        <member name="M:JetBrains.Core.Result.Wrap``1(System.Func{``0})">
            <summary>
            Wrap execution of <see cref="!:f"/>() into <see cref="T:JetBrains.Core.Result`1"/>. 
            </summary>
            <param name="f">Function  to execute</param>
            <typeparam name="TRes">type argument of returned Result</typeparam>
            <returns>Succeed result with <see cref="F:JetBrains.Core.Result`1.Value"/> == f() if no exception happened during <see cref="!:f"/> execution. Failed result with corresponding exception otherwise </returns>
        </member>
        <member name="M:JetBrains.Core.Result.Wrap(System.Action)">
            <summary>
            Wrap execution of <see cref="!:f"/>() into <see cref="T:JetBrains.Core.Result`1"/>. 
            </summary>
            <param name="f">Action to execute</param>
            <returns>Succeed result with <see cref="F:JetBrains.Core.Result.Unit"/> if no exception happened during <see cref="!:f"/> execution. Failed result with corresponding exception otherwise </returns>
        </member>
        <member name="M:JetBrains.Core.Result.Wrap``1(System.Action{``0},``0)">
            <summary>
            Wrap execution of <see cref="!:f"/>(<see cref="!:param"/>) into <see cref="T:JetBrains.Core.Result`1"/>. 
            </summary>
            <param name="f">Action with parameter to execute</param>
            <param name="param">function argument</param>
            <typeparam name="T"><see cref="!:param"/> type</typeparam>
            <returns>Succeed result with <see cref="F:JetBrains.Core.Result.Unit"/> if no exception happened during <see cref="!:f"/> execution. Failed result with corresponding exception otherwise </returns>    
        </member>
        <member name="M:JetBrains.Core.Result.Wrap``2(System.Func{``0,``1},``0)">
            <summary>
            Wrap execution of <see cref="!:f"/>(<see cref="!:param"/>) into <see cref="T:JetBrains.Core.Result`1"/>. 
            </summary>
            <param name="f">Function with parameter to execute</param>
            <param name="param">function argument</param>
            <typeparam name="T"><see cref="!:param"/> type</typeparam>
            <typeparam name="TRes">type argument of returned Result</typeparam>
            <returns>Succeed result with <see cref="F:JetBrains.Core.Result`1.Value"/> == f(param) if no exception happened during <see cref="!:f"/> execution. Failed result with corresponding exception otherwise </returns>    
        </member>
        <member name="M:JetBrains.Core.Result.UnwrapTask(JetBrains.Core.Result{System.Threading.Tasks.Task})">
            <summary>
            Transforms this <see cref="T:JetBrains.Core.Result"/> into <see cref="T:System.Threading.Tasks.Task"/>.
            <see cref="P:JetBrains.Core.Result`1.Succeed"/> corresponds to <see cref="T:System.Threading.Tasks.Task"/> in <see cref="F:JetBrains.Core.Result`1.Value"/>.
            <see cref="P:JetBrains.Core.Result`1.Canceled"/> corresponds to completed task with <see cref="P:System.Threading.Tasks.Task.IsCanceled"/>
            <see cref="P:JetBrains.Core.Result`1.FailedNotCanceled"/> corresponds to completed task with <see cref="P:System.Threading.Tasks.Task.IsFaulted"/> and <see cref="T:System.Exception"/>
            </summary>
            <param name="result">this</param>
            <returns><see cref="T:System.Threading.Tasks.Task"/> that corresponds <see cref="!:result"/></returns>
        </member>
        <member name="M:JetBrains.Core.Result.UnwrapTask``1(JetBrains.Core.Result{System.Threading.Tasks.Task{``0}})">
            <summary>
            Transforms this <see cref="T:JetBrains.Core.Result"/> into <see cref="T:System.Threading.Tasks.Task"/>.
            <see cref="P:JetBrains.Core.Result`1.Succeed"/> corresponds to <see cref="T:System.Threading.Tasks.Task"/> in <see cref="F:JetBrains.Core.Result`1.Value"/>.
            <see cref="P:JetBrains.Core.Result`1.Canceled"/> corresponds to completed task with <see cref="P:System.Threading.Tasks.Task.IsCanceled"/>
            <see cref="P:JetBrains.Core.Result`1.FailedNotCanceled"/> corresponds to completed task with <see cref="P:System.Threading.Tasks.Task.IsFaulted"/> and <see cref="T:System.Exception"/>
            </summary>
            <param name="result">this</param>
            <typeparam name="T">type parameter of returning task</typeparam>
            <returns><see cref="T:System.Threading.Tasks.Task"/> that corresponds <see cref="!:result"/></returns>
        </member>
        <member name="M:JetBrains.Core.Result.FromCompletedTask``1(System.Threading.Tasks.Task{``0})">
            <summary>
            Wrap completed task's result into <see cref="T:JetBrains.Core.Result`1"/> or throw <see cref="T:System.InvalidOperationException"/> is task is <c>!</c><see cref="P:System.Threading.Tasks.Task.IsCompleted"/> 
            </summary>
            <param name="task">Must be finished (<see cref="P:System.Threading.Tasks.Task.IsCompleted"/><c>==true</c>) or <see cref="T:System.InvalidOperationException"/> will be throws</param>
            <typeparam name="T"></typeparam>
            <returns><see cref="M:JetBrains.Core.Result.Success``1(``0)"/>(task.<see cref="P:System.Threading.Tasks.Task`1.Result"/>) or <see cref="M:JetBrains.Core.Result.Fail(System.Exception,System.Boolean)"/>(task.<see cref="P:System.Threading.Tasks.Task.Exception"/>)</returns>
            <exception cref="T:System.InvalidOperationException">in case of <c>!task.</c><see cref="P:System.Threading.Tasks.Task.IsCompleted"/></exception>
        </member>
        <member name="T:JetBrains.Core.Result`1">
            <summary>
            Monad that can can have two states: <see cref="P:JetBrains.Core.Result`1.Succeed"/> and Fail (!<see cref="P:JetBrains.Core.Result`1.Succeed"/>). Also we distinct special type of Fail: <see cref="P:JetBrains.Core.Result`1.Canceled"/>.  
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:JetBrains.Core.Result`1.Value">
            <summary>
            Value in case of <see cref="P:JetBrains.Core.Result`1.Succeed"/>, default(T) otherwise
            </summary>
        </member>
        <member name="F:JetBrains.Core.Result`1.ExceptionOrExceptionDispatchInfo">
            <summary>
            It this field not null, this Result is !<see cref="P:JetBrains.Core.Result`1.Succeed"/> and vise versa.
            </summary>
        </member>
        <member name="P:JetBrains.Core.Result`1.Exception">
            <summary>
            Exception in case of (!<see cref="P:JetBrains.Core.Result`1.Succeed"/>), null otherwise
            </summary>
        </member>
        <member name="P:JetBrains.Core.Result`1.FailMessage">
            <summary>
            Exception message in case of (!<see cref="P:JetBrains.Core.Result`1.Succeed"/>), null otherwise 
            </summary>
        </member>
        <member name="M:JetBrains.Core.Result`1.#ctor(`0,System.Object)">
            <summary>
            Shouldn't be invoked in user's code
            </summary>
            <param name="success"></param>
            <param name="failure"></param>
        </member>
        <member name="P:JetBrains.Core.Result`1.Succeed">
            <summary>
            !<see cref="P:JetBrains.Core.Result`1.Succeed"/> and <see cref="P:JetBrains.Core.Result`1.Canceled"/>
            </summary>
        </member>
        <member name="P:JetBrains.Core.Result`1.FailedNotCanceled">
            <summary>
            (!<see cref="P:JetBrains.Core.Result`1.Succeed"/>) and (<see cref="P:JetBrains.Core.Result`1.Canceled"/>
            </summary>
        </member>
        <member name="P:JetBrains.Core.Result`1.Canceled">
            <summary>
            Exception has specials type of <see cref="T:System.OperationCanceledException"/> or <see cref="T:System.AggregateException"/> that has <see cref="T:System.OperationCanceledException"/> inside.
            </summary>
        </member>
        <member name="M:JetBrains.Core.Result`1.Map``1(System.Func{`0,``0})">
            <summary>
            Transform this result into new one with given function. if !<see cref="P:JetBrains.Core.Result`1.Succeed"/>, stays untouched./> 
            </summary>
            <param name="transform"></param>
            <typeparam name="TRes"></typeparam>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Core.Result`1.Map``1(``0)">
            <summary>
            Map without lambda. Success{Anything} -> Success{<see cref="!:successValue"/>}. Fail -> Fail
            </summary>
            <param name="successValue">In case of success we always create successful result with this value</param>
            <typeparam name="TRes"></typeparam>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Core.Result`1.Unwrap">
            <summary>
            Returns <see cref="F:JetBrains.Core.Result`1.Value"/> if <see cref="P:JetBrains.Core.Result`1.Succeed"/>, throws <see cref="P:JetBrains.Core.Result`1.Exception"/> otherwise
            </summary>
            <returns> <see cref="F:JetBrains.Core.Result`1.Value"/> if <see cref="P:JetBrains.Core.Result`1.Succeed"/> </returns>
            <exception cref="P:JetBrains.Core.Result`1.Exception">if !<see cref="P:JetBrains.Core.Result`1.Succeed"/></exception>
        </member>
        <member name="M:JetBrains.Core.Result`1.AsCompletedTask">
            <summary>
            Transforms this <see cref="T:JetBrains.Core.Result"/> into <see cref="T:System.Threading.Tasks.Task"/> in <see cref="P:System.Threading.Tasks.Task.IsCompleted"/> state state.
            <see cref="P:JetBrains.Core.Result`1.Succeed"/> corresponds to <see cref="!:Task.IsRanToCompletion"/>.
            <see cref="P:JetBrains.Core.Result`1.Canceled"/> corresponds to <see cref="P:System.Threading.Tasks.Task.IsCanceled"/>
            <see cref="P:JetBrains.Core.Result`1.FailedNotCanceled"/> corresponds to <see cref="P:System.Threading.Tasks.Task.IsFaulted"/> with <see cref="P:JetBrains.Core.Result`1.Exception"/>
            </summary>
            <returns><see cref="T:System.Threading.Tasks.Task"/> in <see cref="P:System.Threading.Tasks.Task.IsCompleted"/> state</returns>
        </member>
        <member name="T:JetBrains.Core.Result`2">
            <summary>
            Special kind of <see cref="T:JetBrains.Core.Result`1"/> to store custom <see cref="F:JetBrains.Core.Result`2.FailValue"/> in case of !<see cref="P:JetBrains.Core.Result`2.Succeed"/>. 
            </summary>
            <typeparam name="TSuccess"></typeparam>
            <typeparam name="TFailure"></typeparam>
        </member>
        <member name="F:JetBrains.Core.Result`2.Value">
            <summary>
            Value in case of <see cref="P:JetBrains.Core.Result`2.Succeed"/>, default(T) otherwise
            </summary>
        </member>
        <member name="F:JetBrains.Core.Result`2.ExceptionOrExceptionDispatchInfo">
            <summary>
            It this field not null, this Result is !<see cref="P:JetBrains.Core.Result`2.Succeed"/> and vise versa.
            </summary>
        </member>
        <member name="P:JetBrains.Core.Result`2.Exception">
            <summary>
            Exception in case of (!<see cref="P:JetBrains.Core.Result`2.Succeed"/>), null otherwise
            </summary>
        </member>
        <member name="T:JetBrains.Core.ResultException">
            <summary>
            Exception arising in <see cref="T:JetBrains.Core.Result"/> when do not specify exception explicitly: <see cref="M:JetBrains.Core.Result.Fail(System.String)"/> 
            </summary>
        </member>
        <member name="T:JetBrains.Core.Unit">
            <summary>
            Type that has the single instance. Adornment to <see cref="T:System.Void"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Core.Unit.Instance">
            <summary>
            The only way to get instance of type <see cref="T:JetBrains.Core.Unit"/>
            </summary>
        </member>
        <member name="T:JetBrains.Diagnostics.FirstChanceExceptionInterceptor">
            <summary>
            Facilitates runtime diagnostics when exception arises. In a current thread scope, put diagnostic information in exception if it arises somewhere in call stack.
            All information put will be available with ',' separator under <see cref="F:JetBrains.Diagnostics.FirstChanceExceptionInterceptor.ExceptionDataKey"/> when you print exception
            
            Usage:
            <code>
            using (new FirstChanceExceptionInterceptor.ThreadLocalDebugInfo(your_diagnostic_information))
            {
                you_arbitrary_code
            }
            </code>    
            </summary>
        </member>
        <member name="T:JetBrains.Diagnostics.ILog">
            <summary>
            Logger's frontend. This class is used as entry point for logging in this library and could
            be bound to any logger's backend (say log4net) used in your solution. <see cref="M:JetBrains.Diagnostics.ILog.Log(JetBrains.Diagnostics.LoggingLevel,System.String,System.Exception)"/> 
            </summary>
        </member>
        <member name="T:JetBrains.Diagnostics.ILogFactory">
            <summary>
            Logger's factory frontend. This class could
            be bound to any logger's backend (say log4net) used in your solution. <see cref="T:JetBrains.Diagnostics.Log"/> 
            </summary>
        </member>
        <member name="T:JetBrains.Diagnostics.Internal.SingletonLogFactory">
            <summary>
            This factory always create one instance of <see cref="T:JetBrains.Diagnostics.ILog"/> for any category
            </summary>
        </member>
        <member name="T:JetBrains.Diagnostics.Internal.TextWriterLog">
            <summary>
            Log that able to write to <see cref="T:System.IO.TextWriter"/>
            </summary>
        </member>
        <member name="T:JetBrains.Diagnostics.Internal.TextWriterLogFactory">
            <summary>
            Log factory that create <see cref="T:JetBrains.Diagnostics.Internal.TextWriterLog"/>. Could be created for file by <see cref="M:JetBrains.Diagnostics.Log.CreateFileLogFactory(JetBrains.Lifetimes.Lifetime,System.String,System.Boolean,JetBrains.Diagnostics.LoggingLevel)"/>
            </summary>
        </member>
        <member name="T:JetBrains.Diagnostics.Log">
            <summary>
            Logger configuration entry point. 
            If you want see logs from this library to bound in your solution
            you have to bound <see cref="T:JetBrains.Diagnostics.ILog"/> to some logger implementation library (backend) used in your code base (say log4net)
            by implementing <see cref="T:JetBrains.Diagnostics.ILog"/> and <see cref="T:JetBrains.Diagnostics.ILogFactory"/> and setting them as default by <see cref="M:JetBrains.Diagnostics.Log.set_DefaultFactory(JetBrains.Diagnostics.ILogFactory)"/>. 
            </summary>
        </member>
        <member name="P:JetBrains.Diagnostics.Log.DefaultFactory">
            <summary>
            Set's default (lowest priority) <see cref="T:JetBrains.Diagnostics.ILogFactory"/>. If nothing chosen <see cref="F:JetBrains.Diagnostics.Log.ConsoleVerboseFactory"/> is used
            </summary>
        </member>
        <member name="M:JetBrains.Diagnostics.Log.UsingLogFactory(JetBrains.Diagnostics.ILogFactory)">
            <summary>
            Use this method if you want to set your global log factory (push it to the top of the stack).  
            </summary>
            <param name="factory">Factory to use as global  util returned object is not disposed</param>
            <returns>IDisposable, that should be disposed to return old logger factory. </returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:JetBrains.Diagnostics.Log.GetLog(System.String)">
            <summary>
            Creates log for <see cref="!:category"/>. Dots ('.') are separators between subcategories so all loggers form a hierarchy tree.
            </summary>
            <param name="category"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Diagnostics.Log.GetLog(System.Type)">
            <summary>
            Creates logger for FQN of <paramref name="type"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Diagnostics.Log.GetLog``1">
            <summary>
            Creates logger for FQN of type <see cref="!:T"/>
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Diagnostics.Log.SwitchingLog">
            <summary>
            This class is used automatically as wrapper when you log something. On each log event it checks whether underlying <see cref="F:JetBrains.Diagnostics.Log.SwitchingLog.myFactory"/>
            implementation is switched. So you can substitute new log factories by <see cref="M:JetBrains.Diagnostics.Log.UsingLogFactory(JetBrains.Diagnostics.ILogFactory)"/> and every existing <see cref="T:JetBrains.Diagnostics.ILog"/>
            will be reconfigured on the fly. 
            </summary>
        </member>
        <member name="F:JetBrains.Diagnostics.Log.DefaultDateFormat">
            <summary>
            Default format for <see cref="T:System.DateTime"/> of logging event.
            WARNING!!! don't change it, we have code that do fast formatting according this pattern
            </summary>
        </member>
        <member name="M:JetBrains.Diagnostics.Log.DefaultFormat(System.Nullable{System.DateTime},JetBrains.Diagnostics.LoggingLevel,System.String,System.Threading.Thread,System.String,System.Exception)">
            <summary>
            Default formatting of logging message
            </summary>
            <param name="date"></param>
            <param name="loggingLevel"></param>
            <param name="category"></param>
            <param name="thread"></param>
            <param name="message"></param>
            <param name="exception"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Diagnostics.Log.CreateFileLogFactory(JetBrains.Lifetimes.Lifetime,System.String,System.Boolean,JetBrains.Diagnostics.LoggingLevel)">
            <summary>
            Creates <see cref="T:JetBrains.Diagnostics.ILogFactory"/> that opens file writer. All log messages will be in <see cref="M:JetBrains.Diagnostics.Log.DefaultFormat(System.Nullable{System.DateTime},JetBrains.Diagnostics.LoggingLevel,System.String,System.Threading.Thread,System.String,System.Exception)"/>  
            </summary>
            <param name="lifetime">lifetime of file writer; after lifetime termination file writer will be closed</param>
            <param name="path">path to the file</param>
            <param name="append">append or rewrite file</param>
            <param name="enabledLevel">Filter out all messages with <see cref="T:JetBrains.Diagnostics.LoggingLevel"/> more than this. I.e. enabledLevel == INFO will filter out VERBOSE and TRACE.</param>
            <returns>created factory</returns>
            <exception cref="T:System.Exception"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:JetBrains.Diagnostics.LogEx.Catch(JetBrains.Diagnostics.ILog,System.Action)">
            <summary>
            Run <paramref name="action"/> and in case of exception log it with <see cref="T:JetBrains.Diagnostics.LoggingLevel"/> == ERROR. Do not throw exception (if any). 
            </summary>
            <param name="log"></param>
            <param name="action"></param>
        </member>
        <member name="M:JetBrains.Diagnostics.LogEx.Catch``1(JetBrains.Diagnostics.ILog,System.Func{``0})">
            <summary>
            Run <paramref name="action"/> and in case of exception log it with <see cref="T:JetBrains.Diagnostics.LoggingLevel"/> == ERROR. Do not throw exception (if any). 
            </summary>
            <param name="log"></param>
            <param name="action"></param>
            <returns>result of action() or <c>default(T)></c> if exception arises</returns>
        </member>
        <member name="M:JetBrains.Diagnostics.LogEx.CatchAndDrop(JetBrains.Diagnostics.ILog,System.Action)">
            <summary>
            Run <paramref name="action"/> and in case of exception discard it. Do not throw exception (if any). 
            </summary>
            <param name="log"></param>
            <param name="action"></param>
        </member>
        <member name="M:JetBrains.Diagnostics.LogEx.CatchAndDrop``1(JetBrains.Diagnostics.ILog,System.Func{``0})">
            <summary>
            Run <paramref name="action"/> and in case of exception discard it. Do not throw exception (if any). 
            </summary>
            <param name="log"></param>
            <param name="action"></param>
            <returns>result of action() or <c>default(T)></c> if exception arises</returns>
        </member>
        <member name="M:JetBrains.Diagnostics.LogEx.CatchWarn(JetBrains.Diagnostics.ILog,System.Action)">
            <summary>
            Run <paramref name="action"/> and in case of exception log it with <see cref="T:JetBrains.Diagnostics.LoggingLevel"/> == WARN. Do not throw exception (if any). 
            </summary>
            <param name="log"></param>
            <param name="action"></param>
        </member>
        <member name="M:JetBrains.Diagnostics.LogEx.CatchWarn``1(JetBrains.Diagnostics.ILog,System.Func{``0})">
            <summary>
            Run <paramref name="action"/> and in case of exception log it with <see cref="T:JetBrains.Diagnostics.LoggingLevel"/> == WARN. Do not throw exception (if any). 
            </summary>
            <param name="log"></param>
            <param name="action"></param>
            <returns>result of action() or <c>default(T)></c> if exception arises</returns>
        </member>
        <member name="F:JetBrains.Diagnostics.LoggingLevel.OFF">
            <summary>
            Do not use it in logging. Only in config to disable logging.
            </summary>
        </member>
        <member name="F:JetBrains.Diagnostics.LoggingLevel.FATAL">
            <summary>
            For errors that lead to application failure 
            </summary>
        </member>
        <member name="F:JetBrains.Diagnostics.LoggingLevel.ERROR">
            <summary>
            For errors that must be shown in Exception Browser
            </summary>
        </member>
        <member name="F:JetBrains.Diagnostics.LoggingLevel.WARN">
            <summary>
            Suspicious situations but not errors
            </summary>
        </member>
        <member name="F:JetBrains.Diagnostics.LoggingLevel.INFO">
            <summary>
            Regular level for important events
            </summary>
        </member>
        <member name="F:JetBrains.Diagnostics.LoggingLevel.VERBOSE">
            <summary>
            Additional info for debbuging
            </summary>
        </member>
        <member name="F:JetBrains.Diagnostics.LoggingLevel.TRACE">
            <summary>
            Methods &amp; callstacks tracing, more than verbose
            </summary>
        </member>
        <member name="T:JetBrains.Diagnostics.LogLogRecord">
            <summary>
            log event for <see cref="T:JetBrains.Diagnostics.LogLog"/> 
            </summary>
        </member>
        <member name="T:JetBrains.Diagnostics.LogLog">
            <summary>
            <see cref="T:JetBrains.Diagnostics.Log"/>'s own diagnostics. To record messages and exceptions from logger (and logger referenced code) and don't fall into infinite recursion.
            </summary>
        </member>
        <member name="F:JetBrains.Diagnostics.LogLog.MaxRecordsToStore">
            <summary>
            Sliding window of records
            </summary>
        </member>
        <member name="P:JetBrains.Diagnostics.LogLog.StoredRecords">
            <summary>
            We store last <see cref="F:JetBrains.Diagnostics.LogLog.MaxRecordsToStore"/> loglog records to browse
            </summary>
        </member>
        <member name="T:JetBrains.Diagnostics.RName">
            <summary>
            Recursive name. For constructs like Aaaa.Bbb::CCC
            </summary>
        </member>
        <member name="M:JetBrains.Diagnostics.RName.Sub(System.Object,System.String)">
            <summary>
            Separator doesn't count if localName is empty or parent is empty.
            </summary>
            <param name="localName"></param>
            <param name="separator"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:JetBrains.Lifetimes.ITerminationHandler">
            <summary>
            Alternative to <see cref="M:JetBrains.Lifetimes.Lifetime.OnTermination(System.Action)"/>.
            Special interface for <see cref="T:JetBrains.Lifetimes.Lifetime"/>'s termination participants to implement to avoid memory traffic on lambda creation.
            </summary>
        </member>
        <member name="T:JetBrains.Lifetimes.LifetimeStatus">
            <summary>
            Lifetime's lifecycle statuses. Lifetime is created in <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Alive"/> status and eventually becomes <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Terminated"/>.
            Status change is one way road: from lower ordinal to higher (<c>Alive -> Canceling -> Terminating -> Terminated </c>).  
            </summary>
        </member>
        <member name="F:JetBrains.Lifetimes.LifetimeStatus.Alive">
            <summary>
            Lifetime is ready to use. Every lifetime's method will work. 
            </summary>
        </member>
        <member name="F:JetBrains.Lifetimes.LifetimeStatus.Canceling">
             <summary>
             This status propagates instantly through all lifetime's children graph when <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.Terminate"/> is invoked.
             Lifetime is in consistent state (no resources are terminated) but termination process is already began. All background activities that block
             termination (e.g. started with <see cref="M:JetBrains.Lifetimes.Lifetime.Execute``1(System.Func{``0})"/>, <see cref="M:JetBrains.Lifetimes.Lifetime.ExecuteAsync(System.Func{System.Threading.Tasks.Task})"/>) should be interrupted
             as fast as possible. That's why background activities must check <see cref="P:JetBrains.Lifetimes.Lifetime.IsAlive"/> or <see cref="M:JetBrains.Lifetimes.Lifetime.ThrowIfNotAlive"/>
             quite ofter (200 ms is a good reference value).
            
             Some methods in this status still works, e.g. <see cref="M:JetBrains.Lifetimes.Lifetime.OnTermination(System.Action)"/> others do nothing (<see cref="M:JetBrains.Lifetimes.Lifetime.TryExecute``1(System.Func{``0},System.Boolean)"/>)
             or throw <see cref="T:JetBrains.Lifetimes.LifetimeCanceledException"/> (<see cref="M:JetBrains.Lifetimes.Lifetime.Execute``1(System.Func{``0})"/>, <see cref="M:JetBrains.Lifetimes.Lifetime.Bracket(System.Action,System.Action)"/>)
            
             Associated <see cref="M:JetBrains.Lifetimes.Lifetime.ToCancellationToken"/> is canceled.
             </summary>
        </member>
        <member name="F:JetBrains.Lifetimes.LifetimeStatus.Terminating">
            <summary>
            Lifetime is in inconsistent state. Destruction begins: some resources are terminated, other not. All method throw exception or do nothing
            (e.g. <see cref="M:JetBrains.Lifetimes.Lifetime.TryOnTermination(System.Action)"/>). 
            </summary>
        </member>
        <member name="F:JetBrains.Lifetimes.LifetimeStatus.Terminated">
            <summary>
            Lifetime is fully terminated, all resources are disposed and method's behavior is the same as in <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Terminating"/> state.
            </summary>
        </member>
        <member name="T:JetBrains.Lifetimes.Lifetime">
             <summary>
             Central class in <see cref="N:JetBrains.Lifetimes"/> package. Has two main functions:<br/>
             1. High performance analogue of <see cref="T:System.Threading.CancellationToken"/>. <see cref="T:JetBrains.Lifetimes.LifetimeDefinition"/> is analogue of <see cref="T:System.Threading.CancellationTokenSource"/> <br/>
             2. Inversion of <see cref="T:System.IDisposable"/> pattern (with thread-safety):
             user can add termination resources into Lifetime with bunch of <c>OnTermination</c> (e.g. <see cref="M:JetBrains.Lifetimes.Lifetime.OnTermination(System.Action)"/>) methods.
             When lifetime is being terminated (i.e. it's <see cref="T:JetBrains.Lifetimes.LifetimeDefinition"/> was called <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.Terminate"/>) all
             previously added termination resources are being terminated in stack-way LIFO order. Lifetimes forms a hierarchy with parent-child relations so in single-threaded world child always
             becomes <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Terminated"/> <b>BEFORE</b> parent. Usually this hierarchy is a tree but it some cases (like <see cref="M:JetBrains.Lifetimes.Lifetime.Intersect(JetBrains.Lifetimes.Lifetime[])"/> it can be
             a directed acyclic graph. 
            
             <para>
             Kinds of termination resources:
             <list type="number">
             <item><see cref="T:System.Action"/> - merely invoked on termination</item>
             <item><see cref="T:System.IDisposable"/> - <see cref="M:System.IDisposable.Dispose"/> is called on termination</item>
             <item><see cref="T:JetBrains.Lifetimes.ITerminationHandler"/> - <see cref="M:JetBrains.Lifetimes.ITerminationHandler.OnTermination(JetBrains.Lifetimes.Lifetime)"/> is called on termination</item>
             <item><see cref="T:JetBrains.Lifetimes.LifetimeDefinition"/> - for nested(child) lifetimes created by <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.#ctor(JetBrains.Lifetimes.Lifetime)"/>.
             Child lifetime definition's <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.Terminate"/> method is called.</item>
             </list>
            
             If some resource throws an exception during termination, it will be logged by <see cref="T:JetBrains.Diagnostics.ILog"/> with level <see cref="F:JetBrains.Diagnostics.LoggingLevel.ERROR"/> so termination of other resources
             won't be affected.
            
             
             
             <c>Lifetime</c> could be converted to <see cref="T:System.Threading.CancellationToken"/> by implicit cast or by explicit <see cref="M:JetBrains.Lifetimes.Lifetime.ToCancellationToken"/> to use in task based API. You can start
             </para>
             </summary>
        </member>
        <member name="F:JetBrains.Lifetimes.Lifetime.AsyncLocal">
            <summary>
            Special "async-static" lifetime that is captured when you execute <see cref="M:JetBrains.Lifetimes.Lifetime.ExecuteAsync(System.Func{System.Threading.Tasks.Task})"/> or <see cref="M:JetBrains.Lifetimes.Lifetime.Start(System.Threading.Tasks.TaskScheduler,System.Action,System.Threading.Tasks.TaskCreationOptions)"/>
            and can be used by cooperative cancellation.
            </summary>
        </member>
        <member name="P:JetBrains.Lifetimes.Lifetime.Eternal">
            <summary>
            <para>A lifetime that never ends. Scheduling actions on such a lifetime has no effect.</para>
            <para>Do not call <see cref="M:JetBrains.Lifetimes.Lifetime.AddRef(System.Object)"/> on such a lifetime, because it will not hold your object forever.</para>  
            </summary>
        </member>
        <member name="P:JetBrains.Lifetimes.Lifetime.Terminated">
            <summary>
            Singleton lifetime that is in <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Terminated"/> state by default.  
            </summary>
        </member>
        <member name="P:JetBrains.Lifetimes.Lifetime.Status">
            <summary>
            Lifecycle phase of current lifetime. 
            </summary>
        </member>
        <member name="P:JetBrains.Lifetimes.Lifetime.IsEternal">
            <summary>
            Whether current lifetime is equal to <see cref="P:JetBrains.Lifetimes.Lifetime.Eternal"/> and never be terminated
            </summary>
        </member>
        <member name="P:JetBrains.Lifetimes.Lifetime.IsAlive">
            <summary>
            Is <see cref="P:JetBrains.Lifetimes.Lifetime.Status"/> of this lifetime equal to <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Alive"/>
            </summary>
        </member>
        <member name="P:JetBrains.Lifetimes.Lifetime.IsNotAlive">
            <summary>
            Is <see cref="P:JetBrains.Lifetimes.Lifetime.Status"/> of this lifetime not equal to <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Alive"/>: Termination started already (or even finished).
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:JetBrains.Lifetimes.Lifetime.OnTermination(System.Action)" -->
        <!-- Badly formed XML comment ignored for member "M:JetBrains.Lifetimes.Lifetime.OnTermination(System.IDisposable)" -->
        <!-- Badly formed XML comment ignored for member "M:JetBrains.Lifetimes.Lifetime.OnTermination(JetBrains.Lifetimes.ITerminationHandler)" -->
        <!-- Badly formed XML comment ignored for member "M:JetBrains.Lifetimes.Lifetime.TryOnTermination(System.Action)" -->
        <!-- Badly formed XML comment ignored for member "M:JetBrains.Lifetimes.Lifetime.TryOnTermination(System.IDisposable)" -->
        <!-- Badly formed XML comment ignored for member "M:JetBrains.Lifetimes.Lifetime.TryOnTermination(JetBrains.Lifetimes.ITerminationHandler)" -->
        <member name="P:JetBrains.Lifetimes.Lifetime.ExecutingCount">
            <summary>
            Number of background activities started by <see cref="M:JetBrains.Lifetimes.Lifetime.Execute``1(System.Func{``0})"/>, <see cref="M:JetBrains.Lifetimes.Lifetime.ExecuteAsync(System.Func{System.Threading.Tasks.Task})"/> or <see cref="M:JetBrains.Lifetimes.Lifetime.StartAttached(System.Threading.Tasks.TaskScheduler,System.Action,System.Threading.Tasks.TaskCreationOptions)"/>
            When lifetime became <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Canceling"/> (it happens right after user ask for this lifetime's or ancestor lifetime's definition <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.Terminate"/>) this
            number could only reduce, no new activities can be started.
            When it reach zero, lifetime begins to terminate its resources by changing <see cref="P:JetBrains.Lifetimes.Lifetime.Status"/> to <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Terminating"/>  
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingAllowTerminationUnderExecution">
            <summary>
            If you terminate lifetime definition <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.Terminate"/> under <see cref="M:JetBrains.Lifetimes.Lifetime.Execute``1(System.Func{``0})"/> you'll get exception because 
            it's impossible to keep guarantee that code under <see cref="M:JetBrains.Lifetimes.Lifetime.Execute``1(System.Func{``0})"/> works with non-terminating livetime.
            However if you know what you are doing (e.g. <c>Terminate</c> is the last call in code under <c>Execute</c>), you can take this cookie and allow this behavior.
            </summary>
            <returns>Disposable that allow to call <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.Terminate"/> under <see cref="M:JetBrains.Lifetimes.Lifetime.Execute``1(System.Func{``0})"/> </returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingExecuteIfAlive(System.Boolean)">
            <summary>
            This method could be used as non-allocation version of <see cref="M:JetBrains.Lifetimes.Lifetime.Execute``1(System.Func{``0})"/> or <see cref="M:JetBrains.Lifetimes.Lifetime.TryExecute``1(System.Func{``0},System.Boolean)"/>.
            Typical usage pattern is the following:
            <code>
              using (val cookie = lifetime.ExecuteIfAliveCookie()) {
                if (cookie.Succeed) {
                   // you can rely lifetime's resources are alive here (the same as body of Lifetime.Execute, Lifetime.TryExecute).
                } else {
                  //  lifetime is not alive, return (as TryExecute) or throw OCE (as Execute)
                }
              }
            </code>
            </summary>
            <param name="allowTerminationUnderExecution">Automatically takes <see cref="M:JetBrains.Lifetimes.Lifetime.UsingAllowTerminationUnderExecution"/> under cookie</param>
            <returns>Special disposable object. If <see cref="F:JetBrains.Lifetimes.LifetimeDefinition.ExecuteIfAliveCookie.Succeed"/> than until <c>Dispose</c> current lifetime can't
            become <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Terminating"/> and can't start resources destruction. If <c>!Succeed</c> than lifetime is already
            <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Terminating"/> or <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Terminated"/> </returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.TryExecute``1(System.Func{``0},System.Boolean)">
            <summary>
            
            </summary>
            <param name="action"></param>
            <param name="wrapExceptions"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Using(System.Action{JetBrains.Lifetimes.Lifetime})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Using``1(System.Func{JetBrains.Lifetimes.Lifetime,``0})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingNested(System.Action{JetBrains.Lifetimes.Lifetime})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
              <para>The newly-created lifetime will be nested within the parent  lifetime and thus terminated automatically when the parent lifetime ends (unless the nested lifetime is terminated first).</para>
              <para>Nested lifetimes are listed within the parent lifetime, but as they're terminated, the records are removed. There will be no memory leak on the parent lifetime if the nested lifetimes are terminated.</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingNested``1(System.Func{JetBrains.Lifetimes.Lifetime,``0})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
              <para>The newly-created lifetime will be nested within the parent  lifetime and thus terminated automatically when the parent lifetime ends (unless the nested lifetime is terminated first).</para>
              <para>Nested lifetimes are listed within the parent lifetime, but as they're terminated, the records are removed. There will be no memory leak on the parent lifetime if the nested lifetimes are terminated.</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingAsync(System.Func{JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingAsync``1(System.Func{JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task{``0}})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingAsync(JetBrains.Lifetimes.OuterLifetime,System.Func{JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="parent">A parent lifetime which limits the lifetime given to your action, and migth terminate it before the action ends.</param>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingAsync``1(JetBrains.Lifetimes.OuterLifetime,System.Func{JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task{``0}})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="parent">A parent lifetime which limits the lifetime given to your action, and migth terminate it before the action ends.</param>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingNestedAsync``1(System.Func{JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task{``0}})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
              <para>The parent lifetime which might cause premature termination of our lifetime (and, supposedly, the chain of tasks executed under the lifetime, if started correctly).</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingNestedAsync(System.Func{JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
              <para>The parent lifetime which might cause premature termination of our lifetime (and, supposedly, the chain of tasks executed under the lifetime, if started correctly).</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Synchronize(JetBrains.Lifetimes.LifetimeDefinition[])">
            <summary>
            Synchronizes termination of two lifetime definitions.
            Whenever any one is terminated, the other will be terminated also.
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Intersect(JetBrains.Lifetimes.Lifetime)">
            <summary>
            Creates an intersection with other lifetime  a lifetime to terminate when either one terminates.
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Intersect(JetBrains.Lifetimes.Lifetime,JetBrains.Lifetimes.Lifetime)">
            <summary>
            Creates an intersection of some lifetimes  a lifetime to terminate when either one terminates.
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.DefineIntersection(JetBrains.Lifetimes.Lifetime[])">
            <summary>
            Creates an intersection of some lifetimes  a lifetime to terminate when either one terminates.
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Define(JetBrains.Lifetimes.Lifetime,System.String,System.Action{JetBrains.Lifetimes.LifetimeDefinition})">
            <summary>
              <para>Defines a new lifetime nested within the <paramref name="lifetime" /> you pass in.</para>
            </summary>
            <remarks>
              <para>In most cases, you should have some lifetime to use as a parent, such as the lifetime of your component. If this is not the case, and you just need a function-scoped lifetime, call <see cref="M:JetBrains.Lifetimes.Lifetime.Using(System.Action{JetBrains.Lifetimes.Lifetime})" /> instead. It is terminated automatically when your action ends and thus does not need a parent.</para>
              <para>If the lifetime you're created is really not parented by any other lifetime, use the <see cref="P:JetBrains.Lifetimes.Lifetime.Eternal" /> as a parent.</para>
            </remarks>
            <param name="lifetime">
              <para>The parent lifetime.</para>
              <para>The newly-created lifetime will be nested within the parent lifetime and thus terminated automatically when the parent lifetime ends (unless the nested lifetime is terminated first).</para>
              <para>Nested lifetimes are listed within the parent lifetime, but as they're terminated, the records are removed. There will be no memory leak on the parent lifetime if the nested lifetimes are terminated.</para>
            </param>
            <param name="id">
              <para>Optional. The ID of the lifetime.</para>
              <para>Used for tracking and debugging. If the call stack annotations feature is ON, this ID will appear on the call stack when the lifetime object starts executing scheduled actions upon termination.</para>
              <para>In case of nested lifetimes and if scheduled actions are anonymous in their nature, it might be hard to tell what's happening from exception stack traces without this annotation. You're encouraged to specify IDs wherever such situations are suspected, but the IDs should better be statically defined (to avoid memory leaks on part of the call stacks annotation engine).</para>
              <para>If omitted, the default <see cref="F:JetBrains.Lifetimes.LifetimeDefinition.AnonymousLifetimeId" /> or the <see cref="T:JetBrains.Lifetimes.Lifetime" /> should type name is used, depending on the context.</para>
            </param>
            <param name="atomicAction">
              <para>Optional. The code to be executed atomically on the newly-created lifetime.</para>
              <para>If this code succeeds (or is not specified), the definition of the new lifetime is returned from the method.</para>
              <para>If this code fails with an exception, the newly-created lifetime is terminated, all of the scheduled actions are executed (rolling back any activities already bound to the lifetime), the nested lifetime is not registered no the parent, and the exception is let out of this method.</para>
            </param>    
            <returns>
              <para>The definition to the new lifetime.</para>
              <para>As you own the lifetime, you can terminate it through this definition at any time.</para>
              <para>To pass the lifetime to objects&amp;functions or schedule termination actions on it, get it from the <see cref="P:JetBrains.Lifetimes.LifetimeDefinition.Lifetime" /> property. Do not pass the definition itself to child objects, unless this is the intended scenario to allow them to terminate the lifetime upon their discretion (e. g. a user-cancelable non-modal dialog).</para>
            </returns>
            <seealso cref="M:JetBrains.Lifetimes.Lifetime.Using(System.Action{JetBrains.Lifetimes.Lifetime})" />
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.CreateTaskCompletionSource``1(System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates new <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> that translate <see cref="P:System.Threading.Tasks.Task.Status"/> into canceled if this lifetime becomes terminates (and task wasn't completed before).
            </summary>
            <param name="options">to pass into <see cref="!:TaskCompletionSource&lt;TResult&gt;.ctor"/></param>
            <typeparam name="T"></typeparam>
            <returns>New <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/>. Possibly with already canceled <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task"/> if this lifetime already terminated</returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.AssertEverTerminated(System.String)">
            <summary>
            <para>If this lifetime never gets terminated (and all the references to it get lost), reports an exception to the logger.</para>
            <para>The lifetime will not be terminated automatically, because this is not a lifetime definition. See Remarks for options.</para>
            <para>Note that this method means certain load on the finalization queue, and can degrade performance if used in large amounts.</para>
            <para>Fluent.</para>
            </summary>
            <remarks>
            <para>As this method operates on a <see cref="T:JetBrains.Lifetimes.Lifetime"/> object you do not own, it cannot terminate the lifetime automatically when a missed termination is detected.</para>
            </remarks>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.AssertTerminatesIn(System.TimeSpan,System.String)">
            <summary>
            Log error if this lifetime hasn't been terminated in specified <paramref name="timeout"/> 
            </summary>
            <param name="timeout">Maximum timeout to wait this lifetime is terminated</param>
            <param name="comment">Optional comment to log when assertion failed</param>
        </member>
        <member name="T:JetBrains.Lifetimes.LifetimedList`1">
             <summary>
             List for <see cref="T:JetBrains.Lifetimes.Lifetimed`1"/> entities. Not thread safe but designed to avoid <see cref="T:System.InvalidOperationException"/>
             from <see cref="M:System.Collections.IEnumerator.MoveNext"/> during concurrent modification. So no need to defense copy of internal array.
            
             There are no <see cref="M:System.Collections.Generic.ICollection`1.Remove(`0)"/> method, it's append only. When item's <see cref="P:JetBrains.Lifetimes.Lifetimed`1.Lifetime"/> becomes
             not alive, item's <see cref="P:JetBrains.Lifetimes.Lifetimed`1.Value"/> is cleared (to avoid memory leak) and item is fully removed from internal
             <see cref="F:JetBrains.Lifetimes.LifetimedList`1.myItems"/> array after exponential growth phase in <see cref="M:JetBrains.Lifetimes.LifetimedList`1.EnsureCapacity"/>.
            
              
             </summary>
             <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Lifetimes.OuterLifetime">
            <summary>
              <para>A subset of the <see cref="T:JetBrains.Lifetimes.Lifetime" /> interface with which you cannot bind actions to a lifetime.</para>
              <para>It's outer in the sense that it's not your lifetime, but of some parent object potentially more long-lived than yours. You cannot schedule anything to its termination because it will happen way after your object goes off scope.</para>
              <para>The only thing you can know is that it's an outer, it's limiting the life of your object, and if it's terminated  so are you. Checking for <see cref="P:JetBrains.Lifetimes.OuterLifetime.IsTerminated" /> is one of the allowed option.</para>
              <para>Another option is to define a nested lifetime, in which case you MUST ensure it's terminated explicitly, without relying on the outer lifetime. The outer lifetime is only a safety catch to make sure it does not live too long.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Lifetimes.OuterLifetime.IsTerminated">
            <summary>
              <para>Gets whether this lifetime has already been terminated.</para>
              <para>It's an error to continue scheduling on a terminated lifetime.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.OuterLifetime.UsingNestedAsync``1(System.Func{JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task{``0}})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
              <para>The parent lifetime which might cause premature termination of our lifetime (and, supposedly, the chain of tasks executed under the lifetime, if started correctly).</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.OuterLifetime.UsingNestedAsync(System.Func{JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
              <para>The parent lifetime which might cause premature termination of our lifetime (and, supposedly, the chain of tasks executed under the lifetime, if started correctly).</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.OuterLifetime.Define(JetBrains.Lifetimes.OuterLifetime,System.String,System.Action{JetBrains.Lifetimes.LifetimeDefinition,JetBrains.Lifetimes.Lifetime})">
            <summary>
              <para>See documentation on an overload which takes a <see cref="T:JetBrains.Lifetimes.Lifetime" />.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.OuterLifetime.DefineIntersection(JetBrains.Lifetimes.OuterLifetime[])">
            <summary>
            Creates an intersection of some lifetimes  a lifetime to terminate when either one terminates.
            </summary>
        </member>
        <member name="T:JetBrains.Lifetimes.SequentialLifetimes">
            <summary>
            Maintains a sequence of lifetimes, so that the previous lifetime is closed before the new one is opened.
            Good for implementing a sequence of non-simultaneous activities when it's nice to guarantee only one is active at a time.
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.SequentialLifetimes.#ctor(JetBrains.Lifetimes.Lifetime)">
            <summary>Creates and binds to the lifetime.</summary>
            <param name="lifetime">When this lifetime is closed, the last of the sequential lifetimes is closed too.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.SequentialLifetimes.Next(System.Action{JetBrains.Lifetimes.Lifetime})">
            <summary>
            Terminates the current lifetime and calls your handler with the new lifetime.
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.SequentialLifetimes.TerminateCurrent">
            <summary>
            Terminates the current lifetime and calls your handler with the new lifetime.
            The lifetime definition allows to terminate it as desired.
            Also, the lifetime will be terminated when either parent lifetime is terminated,
            or <see cref="M:JetBrains.Lifetimes.SequentialLifetimes.TerminateCurrent"/> is called, or <see cref="M:JetBrains.Lifetimes.SequentialLifetimes.DefineNext(System.Action{JetBrains.Lifetimes.LifetimeDefinition})"/>/<see cref="M:JetBrains.Lifetimes.SequentialLifetimes.Next"/> is called.
            </summary>
            <summary>
            Terminates the current lifetime.
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.SequentialLifetimes.SetNextAndTerminateCurrent(JetBrains.Lifetimes.LifetimeDefinition)">
            <summary>
            Atomically, assigns the new lifetime and terminates the old one.
            </summary>
        </member>
        <member name="M:JetBrains.Serialization.UnsafeReader.ReadCollection``2(JetBrains.Serialization.UnsafeReader.ReadDelegate{``0},System.Func{System.Int32,``1})">
            <summary>
            Non optimal collection serialization. One can serialize internal structure (eg. array) instead.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TCol"></typeparam>
            <param name="readDelegate"></param>
            <param name="constructor"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Serialization.UnsafeWriter.Cookie.WriteIntLengthToCookieStart">
            <summary>
            Writes `<see cref="P:JetBrains.Serialization.UnsafeWriter.Cookie.Count"/><c> - sizeof(int)</c>` into the <see cref="P:JetBrains.Serialization.UnsafeWriter.Cookie.Data"/> pointer. Cookie must be prepared by invoking `<see cref="M:JetBrains.Serialization.UnsafeWriter.Write(System.Int32)"/><c>(0)</c>` as first cookie call.
            </summary>
        </member>
        <member name="M:JetBrains.Serialization.UnsafeWriter.WriteStringContent(System.String)">
            <summary>
            Doesn't write length prefix, only string contents. If value == null, does nothing.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:JetBrains.Serialization.UnsafeWriter.WriteStringContent(System.String,System.Int32,System.Int32)">
            <summary>
            Doesn't write length prefix, only string contents. If value == null, does nothing.
            </summary>
            <param name="value"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:JetBrains.Serialization.UnsafeWriter.Alloc(System.Int32)">
            <summary>
            Correctly allocates the number of bytes as if they were written with any func, and advances the pointer past them.
            This is useful if you want to use buffer space for direct memory access.
            Take the <see cref="P:JetBrains.Serialization.UnsafeWriter.Ptr" /> value before calling <see cref="M:JetBrains.Serialization.UnsafeWriter.Alloc(System.Int32)" /> to address the space correctly.
            </summary>
        </member>
        <member name="M:JetBrains.Serialization.UnsafeWriter.Write``2(JetBrains.Serialization.UnsafeWriter.WriteDelegate{``0},``1)">
            <summary>
            Non optimal collection serialization. You can serialize internal structure (eg. array) instead.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ByteBufferAsyncProcessor.Start">
            <summary>
            Starts async processing of queue.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ByteBufferAsyncProcessor.Stop(System.Int32)">
            <summary>
            Graceful stop. Process queue, but doesn't accept new data via <see cref="M:JetBrains.Threading.ByteBufferAsyncProcessor.Put(System.Byte[])"/>. Joins processing thread for given timeout. If timeout elapsed, aborts thread.
            </summary>
            <param name="timeoutMs">Timeout to wait. <see cref="F:System.Threading.Timeout.Infinite"/> for infinite waiting.</param>
            <returns>'true' if Join(timeoutMs) was successful, false otherwise. Also returns 'false' if thread is already stopped or killed."></returns>
        </member>
        <member name="M:JetBrains.Threading.ByteBufferAsyncProcessor.Terminate(System.Int32)">
            <summary>
            Force stop. Doesn't process queue, doesn't accept new data via <see cref="M:JetBrains.Threading.ByteBufferAsyncProcessor.Put(System.Byte[])"/>. Joins processing thread for given timeout. If timeout elapsed, aborts thread.
            </summary>
            <param name="timeoutMs">Timeout to wait. <see cref="F:System.Threading.Timeout.Infinite"/> for infinite waiting.</param>
            <returns>'true' if Join(timeoutMs) was successful, false otherwise. Also returns 'false' if thread is already stopped or killed."></returns>
        </member>
        <member name="M:JetBrains.Threading.ExceptionEx.IsOperationCanceled(System.Exception)">
            <summary>
            Whether this exception is <see cref="T:System.OperationCanceledException"/> or <see cref="P:System.Exception.InnerException"/> is <see cref="T:System.OperationCanceledException"/>
            (e.g. <c>"TargetInvocationException"</c>) or Inner.Inner and so on.
            Or this exception is <see cref="T:System.AggregateException"/> that consists only from <see cref="T:System.OperationCanceledException"/> (or exception that has OCE as Inner exception).
            </summary>
            <param name="exception">exception to test or null</param>
            <returns>if <paramref name="exception"/> is null, returns false. Otherwise tries to run algorithm from the summary.</returns>
        </member>
        <member name="T:JetBrains.Threading.ProactiveLazy`1">
            <summary>
            Holder that starts evaluation immediately right in the constructor in background. 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Threading.SpinWaitEx">
            <summary>
            Extensions for <see cref="T:System.Threading.SpinWait"/> static methods.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.SpinWaitEx.SpinUntil(System.Func{System.Boolean})">
            <summary>
            Spins while <paramref name="condition"/> is false.     
            </summary>
            <param name="condition">Stops spinning when condition is true</param>
        </member>
        <member name="M:JetBrains.Threading.SpinWaitEx.SpinUntil(JetBrains.Lifetimes.Lifetime,System.Func{System.Boolean})">
            <summary>
            Spins while <paramref name="lifetime"/> is alive and <paramref name="condition"/> is false.     
            </summary>
            <param name="lifetime">Stops spinning and return <c>false</c> when lifetime is no more alive</param>
            <param name="condition">Stops spinning and return <c>false</c> when condition is true</param>
            <returns><c>false</c> if <paramref name="lifetime"/> is not alive or canceled during spinning.
            Otherwise <c>true</c> (when <paramref name="condition"/> returns true)</returns>
        </member>
        <member name="M:JetBrains.Threading.SpinWaitEx.SpinUntil(JetBrains.Lifetimes.Lifetime,System.TimeSpan,System.Func{System.Boolean})">
            <summary>
            Spins while <paramref name="lifetime"/> is alive, <paramref name="timeout"/> is not elapsed and <paramref name="condition"/> is false.     
            </summary>
            <param name="lifetime">Stops spinning and return <c>false</c> when lifetime is no more alive</param>
            <param name="timeout">Stops spinning and return <c>false</c> when timeout is alive</param>
            <param name="condition">Stops spinning and return <c>false</c> when condition is true</param>
            <returns><c>false</c> if <paramref name="lifetime"/> is not alive or canceled during spinning, <paramref name="timeout"/> is zero or elapsed during spinning.
            Otherwise <c>true</c> (when <paramref name="condition"/> returns true)</returns>
        </member>
        <member name="M:JetBrains.Threading.SpinWaitEx.SpinUntil(JetBrains.Lifetimes.Lifetime,System.Int64,System.Func{System.Boolean})">
            <summary>
            Spins while <paramref name="lifetime"/> is alive, <paramref name="timeoutMs"/> is not elapsed and <paramref name="condition"/> is false.     
            </summary>
            <param name="lifetime">Stops spinning and return <c>false</c> when lifetime is no more alive</param>
            <param name="timeoutMs">Stops spinning and return <c>false</c> when timeout is alive</param>
            <param name="condition">Stops spinning and return <c>false</c> when condition is true</param>
            <returns><c>false</c> if <paramref name="lifetime"/> is not alive or canceled during spinning, <paramref name="timeoutMs"/> is zero or elapsed during spinning.
            Otherwise <c>true</c> (when <paramref name="condition"/> returns true)</returns>    
        </member>
        <member name="M:JetBrains.Threading.SpinWaitEx.SpinUntilAsync(JetBrains.Lifetimes.Lifetime,System.Int64,System.Int32,System.Func{System.Boolean})">
            <summary>
            Spins in ASYNC manner (not consuming thread or CPU resources) while <paramref name="lifetime"/> is alive, <paramref name="timeoutMs"/> is not elapsed and <paramref name="condition"/> is false.
            Sleeps in async fashion (using <see cref="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)"/> for <paramref name="delayBetweenChecksMs"/> each time between <paramref name="condition"/> check.
            Only <paramref name="lifetime"/> cancellation could immediately return execution from delay. 
            </summary>
            <param name="lifetime">Stops spinning and return <c>false</c> when lifetime is no more alive</param>
            <param name="timeoutMs">Stops spinning and return <c>false</c> when timeout is alive</param>
            <param name="delayBetweenChecksMs">Interval to delay</param>
            <param name="condition">Stops spinning and return <c>false</c> when condition is true</param>
            <returns><c>false</c> if <paramref name="lifetime"/> is not alive or canceled during spinning, <paramref name="timeoutMs"/> is zero or elapsed during spinning.
            Otherwise <c>true</c> (when <paramref name="condition"/> returns true)</returns> 
        </member>
        <member name="M:JetBrains.Threading.TaskEx.NoAwait(System.Threading.Tasks.Task)">
            <summary>
              <para>Marks that this task is intentionally not awaited or continued-with.</para>
              <para>The task is let to run, its return value (if any) is abandoned, its exceptions are consumed by our logger.</para>
              <para>Prevents Compiler Warning (level 1) CS4014 Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the 'await' operator to the result of the call.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.TaskEx.ToResultProperty``1(System.Threading.Tasks.Task{``0})">
            <summary>
            Transform this task into <see cref="T:JetBrains.Collections.Viewable.ViewableProperty`1"/>. Task could be finished by exception so we need
            </summary>
            <param name="task"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:JetBrains.Threading.TaskEx.GetOrWait``1(System.Threading.Tasks.Task{``0},JetBrains.Lifetimes.Lifetime)">
            <summary>
            Waits for result of given task or throw <see cref="T:System.OperationCanceledException"/> 
            </summary>
            <param name="task">Task to wait</param>
            <param name="lifetime">Cancellation token for </param>
            <typeparam name="T"></typeparam>
            <returns><see cref="!:Task.Result"/> of <paramref name="task"/></returns>
        </member>
        <member name="M:JetBrains.Threading.TaskEx.IsOperationCanceled(System.Threading.Tasks.Task)">
            <summary>
            Return true only if task finished and finished with exception that is or consists only from <see cref="T:System.OperationCanceledException"/>.
            Allow to dive through all <see cref="T:System.AggregateException"/> and Inner exceptions.
            </summary>
            <param name="task"></param>
            <returns>true only if task finished and resulting exception matches <see cref="M:JetBrains.Threading.ExceptionEx.IsOperationCanceled(System.Exception)"/></returns>
        </member>
        <member name="M:JetBrains.Threading.TaskEx.Select``2(System.Threading.Tasks.Task{``0},System.Func{``0,``1})">
            <summary>
            Transform result of original task right after it finished (with <see cref="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)"/> == false).
            If task is not successfully finished then throw original exception. 
            </summary>
            <param name="task">original task</param>
            <param name="selector">transform function from original type to destination one</param>
            <typeparam name="TSrc">original type</typeparam>
            <typeparam name="TDst">destination type</typeparam>
            <returns>new task that is considered completed right after original task completes</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
    </members>
</doc>
